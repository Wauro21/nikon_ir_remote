#include <avr/io.h>
#include <avr/interrupt.h>
#include "functions.h"

#define TIME_SELECTOR_IO ADC3D

/// @brief Counts the number of match interrupts generated by Timer0
volatile uint16_t t0_interrupt_counter = 0U;
/// @brief Controls the current state of the modulation of the 38kHZ signal
volatile uint8_t t0_modulation_state = 0U;
/// @brief holds the number of times the ISR has been used for a single CMD
volatile uint8_t t0_cmd_counter = 0U;
/// @brief The number of Timer 1 interruptions by overflow
volatile uint16_t t1_interrupt_counter = 0U;
/// @brief The maximum number of interrupts for Timer 1
volatile uint16_t t1_max_counter_value = 0U;


int main(void){
    adc_status = 0x00;
    t0_status = 0x00;
    t0_out_enable = 0x00;

    /// TEMPORAL -> Enable when pin is high
    DDRB = 0; /// Inputs -> PB3 potentiometer, PB4 button
    DDRB |= _BV(PB0); /// PB0 used for IR led.

    PORTB = 0; /// TEMPORAL
    PORTB |= _BV(PB4); // Enable pull up of PB4

    /// Interrupts 
    // MCUCR = 0;
    // MCUCR |= _BV(ISC01); /// Falling edge on pin generates interrupts

    GIMSK = 0;
    // GIMSK |= _BV(PCIE); /// Enable pin change interrupt

    PCMSK = 0;
    PCMSK |= _BV(PCINT4); /// Enable pin change interrupt on PB4


    /// ADC configurations
    ADMUX = 0;
    ADCSRA = 0;
    ADCSRB = 0;

    /// Set left adjust (8bit precision) and PB3 as input
    ADMUX |= _BV(ADLAR) | TIME_SELECTOR_IO;

    /// Enable ADC interrupts and select 128 prescaler for 62,5 kHz sampling freq
    ADCSRA |= _BV(ADIE) | _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
    

    // /// TIMERS CONFIGURATION
    /// TIMER 0
    TCCR0A = 0;
    TCCR0B = 0;
    TCNT0 = 0;
    TIMSK = 0;
    TCCR0A |= _BV(COM0A0) | _BV(WGM01); // Set toggle on match and CTC mode
    //TCCR0B |= _BV(CS00);                // internal clock no-prescaling
    OCR0A = 104;                        // For app 38,8kHz



    /// TIMER 1
    TCCR1 = 0;
    GTCCR = 0;
    TCNT1 = 0;
    TIMSK = 0;
    /// Enable timer1 interrupt overflow and Timer0 for CTC
    TIMSK |= _BV(TOIE1) | _BV(OCIE0A);


    sei();

    while(1){
        if(readButton()){
            /// Read adc and set timer 1 limit
            readInterval();
            if(t1_max_counter_value == 0U) sendCMD();
            else PORTB |= _BV(PB0);
        }
    };

}

ISR(ADC_vect){
    /// Read the ADC value and set the mode
    switch(ADCH){
        case 0U ... 8U:
            t1_max_counter_value = 0U;
            break;
        
        case 9U ... 21:
            t1_max_counter_value = 1U; // 1sec
            break;

        case 22 ... 34:
            t1_max_counter_value = 3U; // 2 sec
            break;

        case 35 ... 47:
            t1_max_counter_value = 5U; // 3 sec
            break;

        case 48 ... 60:
            t1_max_counter_value = 7U; // 4 sec
            break;

        case 61 ... 73:
            t1_max_counter_value = 9U; // 5 sec
            break;

        case 74 ... 86:
            t1_max_counter_value = 11U; // 6 sec
            break;

        case 87 ... 99:
            t1_max_counter_value = 13U; // 7 sec
            break;

        case 100 ... 112:
            t1_max_counter_value = 15U; // 8 sec
            break;

        case 113 ... 125:
            t1_max_counter_value = 17U; // 9 sec
            break;

        case 126 ... 138:
            t1_max_counter_value = 19U; // 10 sec
            break;

        case 139 ... 151:
            t1_max_counter_value = 39U; // 20 sec
            break;

        case 152 ... 164:
            t1_max_counter_value = 59U; // 30 sec
            break;

        case 165 ... 177:
            t1_max_counter_value = 79U; // 40 sec
            break;

        case 178 ... 190:
            t1_max_counter_value = 99U; // 50 sec
            break;

        case 191 ... 203:
            t1_max_counter_value = 119U; // 60 sec
            break;

        case 204 ... 216:
            t1_max_counter_value = 239U; // 120 sec
            break;

        case 217 ... 229:
            t1_max_counter_value = 359U; // 180 sec
            break;

        case 230 ... 242: 
            t1_max_counter_value = 479U; // 240 sec
            break;

        case 243 ... 255:
            t1_max_counter_value = 299U; // 300 sec
            break;

        default:
            t1_max_counter_value = 0U;
    };

    /// Set the status flag to escape read-loop
    adc_status = 0x01;
}


ISR(TIMER1_OVF_vect){
    if(t1_interrupt_counter < t1_max_counter_value) t1_interrupt_counter += 1;
    else t1_interrupt_counter = 0;
}


/// @brief Generates the <shot> command by modulating the 38kHz wave generated by Timer0
/// @param void 
ISR(TIMER0_COMPA_vect){
    switch (t0_modulation_state)
    {
        case 0:
            if (t0_interrupt_counter < 151U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x00;
                t0_interrupt_counter = 0;
                t0_modulation_state = 1;
            }
            break;

        case 1:
            if (t0_interrupt_counter < 2127U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x01;
                t0_interrupt_counter = 0;
                t0_modulation_state = 2;
            }
            break;

        case 2:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x00;
                t0_interrupt_counter = 0;
                t0_modulation_state = 3;
            }
            break;

        case 3:
            if (t0_interrupt_counter < 119U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x01;
                t0_interrupt_counter = 0;
                t0_modulation_state = 4;
            }
            break;

        case 4:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x00;
                t0_interrupt_counter = 0;
                t0_modulation_state = 5;
            }
            break;

        case 5:
            if (t0_interrupt_counter < 271U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x01;
                t0_interrupt_counter = 0;
                t0_modulation_state = 6;
            }
            break;

        case 6:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x00;
                t0_interrupt_counter = 0;
                t0_modulation_state = 7;
            }
            break;

        case 7:
            if (t0_interrupt_counter < 4853U) t0_interrupt_counter += 1;
            else{
                if(t0_cmd_counter == 0U){
                    t0_out_enable = 0x01;
                    t0_interrupt_counter = 0;
                    t0_modulation_state = 0;
                    t0_cmd_counter += 1;
                }

                else{
                    t0_out_enable = 0x00;
                    t0_interrupt_counter = 0U;
                    t0_modulation_state = 0U;
                    t0_cmd_counter = 0U;
                    t0_status = 0x00;
                }
            }
            break;
    }
}
