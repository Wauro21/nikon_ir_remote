#include <avr/io.h>
#include <avr/interrupt.h>
#include "functions.h"

#define TIME_SELECTOR_IO ADC3D

/// @brief Counts the number of match interrupts generated by Timer0
volatile uint16_t t0_interrupt_counter = 0U;
/// @brief Controls the current state of the modulation of the 38kHZ signal
volatile uint8_t t0_modulation_state = 0U;
/// @brief holds the number of times the ISR has been used for a single CMD
volatile uint8_t t0_cmd_counter = 0U;
/// @brief The number of Timer 1 interruptions by overflow
volatile uint16_t t1_interrupt_counter = 0U;
/// @brief The maximum number of interrupts for Timer 1
volatile uint16_t t1_max_counter_value = 0U;


/// TEMPORAL
volatile uint8_t stop_button_timer = 0U;
volatile uint8_t stop_button_flag = 0U;

int main(void){
    /// WIP
    uint8_t button_state = 0x00;
    uint8_t adc_enable = 0x00;
    // uint8_t t1_config_flag = 0x00;
    uint8_t busy = 0x00;
    uint8_t stop = 0x00;

    uint32_t button_debounce = 0;


    adc_status = 0x00;
    t0_status = 0x00;
    t0_out_enable = 0x00;

    /// TEMPORAL -> Enable when pin is high
    DDRB = 0; /// Inputs -> PB3 potentiometer, PB2 button
    DDRB |= _BV(PB0) | _BV(PB4); /// PB0 used for IR led.

    PORTB = 0; /// TEMPORAL
    PORTB |= _BV(PB2); // Enable pull up of PB2

    /// Interrupts 
    MCUCR = 0;

    GIMSK = 0;
    // GIMSK |= _BV(PCIE); /// Enable pin change interrupt

    PCMSK = 0;
    // PCMSK |= _BV(PCINT4); /// Enable pin change interrupt on PB4


    /// ADC configurations
    ADMUX = 0;
    ADCSRA = 0;
    ADCSRB = 0;

    /// Set left adjust (8bit precision) and PB3 as input
    ADMUX |= _BV(ADLAR) | TIME_SELECTOR_IO;

    /// Enable ADC interrupts and select 128 prescaler for 62,5 kHz sampling freq
    ADCSRA |= _BV(ADIE) | _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
    

    // /// TIMERS CONFIGURATION
    /// TIMER 0
    TCCR0A = 0;
    TCCR0B = 0;
    TCNT0 = 0;
    TIMSK = 0;
    TCCR0A |= _BV(COM0A0) | _BV(WGM01); // Set toggle on match and CTC mode
    //TCCR0B |= _BV(CS00);                // internal clock no-prescaling
    OCR0A = 104;                        // For app 38,8kHz



    /// TIMER 1
    TCCR1 = 0;
    GTCCR = 0;
    TCNT1 = 0;
    TIMSK = 0;
    /// Enable timer1 interrupt overflow and Timer0 for CTC
    TIMSK |= _BV(TOIE1) | _BV(OCIE0A);


    sei();

    while(1){

        /// Check the button state
        button_state = readButton(&button_debounce);
        if((button_state == 0x01) && (busy == 0x00)) {
            busy = 0x01;
            adc_enable = 0x01;
        }

        else if(button_state == 0x02 && busy == 0x01){
            stop_button_flag = 0x01;
            if(stop_button_timer == 10U){
                PORTB |= _BV(PB4);
                stop = 0x01;
            }
        }

        else if(button_state == 0x01 && stop == 0x01){
            busy = 0x00;
            stopTimer1();
            t1_interrupt_counter = 0U;
            stop_button_timer = 0U;
            stop_button_flag = 0U;
            PORTB &= ~_BV(PB4);
        }

        /// Start shot routine
        
        /// Reads the pot value
        if(adc_enable == 0x01){
            readInterval();
            adc_enable = 0x00;
        }

        /// Starts shoting
        if(busy){
            if(t1_max_counter_value == 0U){
                sendCMD();
                busy = 0x00;
            }
            else{
                startTimer1();
                if(t1_interrupt_counter == 0U) sendCMD();
            }
        }
        


        // if(readButton()){
        //     /// Read adc and set timer 1 limit
        //     readInterval();
        //     if(t1_max_counter_value == 0U) sendCMD();
        //     else{
        //         /// Start timer 1
        //         startTimer1();
        //         while(1){
        //             if(t1_interrupt_counter == 0U) sendCMD();

        //         }
        //     }
        // }
    };

}

// ISR(INT0_vect){
//     PORTB ^= _BV(PB4);
// }

ISR(ADC_vect){
    /// Read the ADC value and set the mode
    switch(ADCH){
        case 0U ... 8U:
            t1_max_counter_value = 0U;
            break;
        
        case 9U ... 21:
            t1_max_counter_value = 1U; // 1sec
            break;

        case 22 ... 34:
            t1_max_counter_value = 3U; // 2 sec
            break;

        case 35 ... 47:
            t1_max_counter_value = 5U; // 3 sec
            break;

        case 48 ... 60:
            t1_max_counter_value = 7U; // 4 sec
            break;

        case 61 ... 73:
            t1_max_counter_value = 9U; // 5 sec
            break;

        case 74 ... 86:
            t1_max_counter_value = 11U; // 6 sec
            break;

        case 87 ... 99:
            t1_max_counter_value = 13U; // 7 sec
            break;

        case 100 ... 112:
            t1_max_counter_value = 15U; // 8 sec
            break;

        case 113 ... 125:
            t1_max_counter_value = 17U; // 9 sec
            break;

        case 126 ... 138:
            t1_max_counter_value = 19U; // 10 sec
            break;

        case 139 ... 151:
            t1_max_counter_value = 39U; // 20 sec
            break;

        case 152 ... 164:
            t1_max_counter_value = 59U; // 30 sec
            break;

        case 165 ... 177:
            t1_max_counter_value = 79U; // 40 sec
            break;

        case 178 ... 190:
            t1_max_counter_value = 99U; // 50 sec
            break;

        case 191 ... 203:
            t1_max_counter_value = 119U; // 60 sec
            break;

        case 204 ... 216:
            t1_max_counter_value = 239U; // 120 sec
            break;

        case 217 ... 229:
            t1_max_counter_value = 359U; // 180 sec
            break;

        case 230 ... 242: 
            t1_max_counter_value = 479U; // 240 sec
            break;

        case 243 ... 255:
            t1_max_counter_value = 599U; // 300 sec
            break;

        default:
            t1_max_counter_value = 0U;
    };

    /// Set the status flag to escape read-loop
    adc_status = 0x01;
}


ISR(TIMER1_OVF_vect){
    if(t1_interrupt_counter < t1_max_counter_value) t1_interrupt_counter += 1;
    else t1_interrupt_counter = 0;

    if(stop_button_flag) stop_button_timer += 1U;
}


/// @brief Generates the <shot> command by modulating the 38kHz wave generated by Timer0
/// @param void 
ISR(TIMER0_COMPA_vect){
    switch (t0_modulation_state)
    {
        case 0:
            if (t0_interrupt_counter < 151U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x00;
                t0_interrupt_counter = 0;
                t0_modulation_state = 1;
            }
            break;

        case 1:
            if (t0_interrupt_counter < 2127U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x01;
                t0_interrupt_counter = 0;
                t0_modulation_state = 2;
            }
            break;

        case 2:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x00;
                t0_interrupt_counter = 0;
                t0_modulation_state = 3;
            }
            break;

        case 3:
            if (t0_interrupt_counter < 119U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x01;
                t0_interrupt_counter = 0;
                t0_modulation_state = 4;
            }
            break;

        case 4:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x00;
                t0_interrupt_counter = 0;
                t0_modulation_state = 5;
            }
            break;

        case 5:
            if (t0_interrupt_counter < 271U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x01;
                t0_interrupt_counter = 0;
                t0_modulation_state = 6;
            }
            break;

        case 6:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = 0x00;
                t0_interrupt_counter = 0;
                t0_modulation_state = 7;
            }
            break;

        case 7:
            if (t0_interrupt_counter < 4853U) t0_interrupt_counter += 1;
            else{
                if(t0_cmd_counter == 0U){
                    t0_out_enable = 0x01;
                    t0_interrupt_counter = 0;
                    t0_modulation_state = 0;
                    t0_cmd_counter += 1;
                }

                else{
                    t0_out_enable = 0x00;
                    t0_interrupt_counter = 0U;
                    t0_modulation_state = 0U;
                    t0_cmd_counter = 0U;
                    t0_status = 0x00;
                }
            }
            break;
    }
}
