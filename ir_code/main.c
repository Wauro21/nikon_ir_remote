#include <avr/io.h>
#include <avr/interrupt.h>
#include "functions.h"

/// @brief Counts the number of match interrupts generated by Timer0
volatile uint16_t t0_interrupt_counter = 0U;
/// @brief Controls the current state of the modulation of the 38kHZ signal
volatile uint8_t t0_modulation_state = 0U;
/// @brief Holds the required state for the Timer0 out pin.
volatile t0_pinout_states t0_out_enable = IDLE;

int main(void){
    DDRB |= _BV(PB0) | _BV(PB1) | _BV(PB2);
    PORTB &= ~_BV(PB1);
    // Set general register to sync mode for configuration
    GTCCR |= _BV(TSM) | _BV(PSR0);
    // Setup the timer0
    setupTimer0();
    // t0_out_enable timer 0 interrup
    TIMSK |= _BV(OCIE0A);
    // t0_out_enable timer
    GTCCR &= ~_BV(TSM) & ~_BV(PSR0);
    // t0_out_enable global interrupts
    sei();


    while (1){
        // Update the state of the Timer 0 pin
        switch (t0_out_enable){
            case IDLE:
                break;

            case ON:
                TCCR0A |= _BV(COM0A0);
                break;

            case OFF:
                TCCR0A &= ~_BV(COM0A0);
                break;
        }
    };
}



/// @brief Generates the <shot> command by modulating the 38kHz wave generated by Timer0
/// @param void 
ISR(TIMER0_COMPA_vect){
    switch (t0_modulation_state)
    {
        case 0:
            if (t0_interrupt_counter < 151U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = OFF;
                t0_interrupt_counter = 0;
                t0_modulation_state = 1;
            }
            break;

        case 1:
            if (t0_interrupt_counter < 2127U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = ON;
                t0_interrupt_counter = 0;
                t0_modulation_state = 2;
            }
            break;

        case 2:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = OFF;
                t0_interrupt_counter = 0;
                t0_modulation_state = 3;
            }
            break;

        case 3:
            if (t0_interrupt_counter < 119U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = ON;
                t0_interrupt_counter = 0;
                t0_modulation_state = 4;
            }
            break;

        case 4:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = OFF;
                t0_interrupt_counter = 0;
                t0_modulation_state = 5;
            }
            break;

        case 5:
            if (t0_interrupt_counter < 271U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = ON;
                t0_interrupt_counter = 0;
                t0_modulation_state = 6;
            }
            break;

        case 6:
            if (t0_interrupt_counter < 29U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = OFF;
                t0_interrupt_counter = 0;
                t0_modulation_state = 7;
            }
            break;

        case 7:
            if (t0_interrupt_counter < 4853U) t0_interrupt_counter += 1;
            else{
                t0_out_enable = ON;
                t0_interrupt_counter = 0;
                t0_modulation_state = 0;
            }
            break;
    }
}
