#include <avr/io.h>
#include <avr/interrupt.h>
#include "functions.h"

/// @brief Counts the number of match interrupts generated by Timer0
volatile uint16_t t0_interrutp_counter = 0U;
/// @brief Controls the current state of the modulation of the 38kHZ signal
volatile uint8_t t0_modulation_state = 0U;
/// @brief Holds the required state for the Timer0 out pin. 
volatile uint8_t t0_out_enable = 0U;



int main(void)
{
    DDRB |= _BV(PB0) | _BV(PB1) | _BV(PB2);
    PORTB &= ~_BV(PB1);
    // Set general register to sync mode for configuration
    GTCCR |= _BV(TSM) | _BV(PSR0);
    // Setup the timer0
    setupTimer0();
    // t0_out_enable timer 0 interrup
    TIMSK |= _BV(OCIE0A);
    // t0_out_enable timer
    GTCCR &= ~_BV(TSM) & ~_BV(PSR0);
    // t0_out_enable global interrupts
    sei();
    while (1){
        if(t0_out_enable == 1) {
            TCCR0A |= _BV(COM0A0);
            t0_out_enable = 0;
        }

        else if(t0_out_enable == 2) {
            TCCR0A &= ~_BV(COM0A0);
            t0_out_enable = 0;
        }
    };
}
// Demo interrupt service routine
ISR(TIMER0_COMPA_vect)
{
    switch (t0_modulation_state)
    {
        case 0:
            if(t0_interrutp_counter < 151U) t0_interrutp_counter += 1;
            else {
                t0_out_enable = 2U;
                t0_interrutp_counter = 0;
                t0_modulation_state = 1;
            }
            break;

        case 1:
            if(t0_interrutp_counter < 2127U) t0_interrutp_counter += 1;
            else {
                t0_out_enable = 1U;
                t0_interrutp_counter = 0;
                t0_modulation_state = 2;
            }
            break;

        case 2:
            if(t0_interrutp_counter < 29U) t0_interrutp_counter += 1;
            else {
                t0_out_enable = 2U;
                t0_interrutp_counter = 0;
                t0_modulation_state = 3;
            }
            break;

        case 3:
            if(t0_interrutp_counter < 119U) t0_interrutp_counter += 1;
            else {
                t0_out_enable = 1U;
                t0_interrutp_counter = 0;
                t0_modulation_state = 4;
            }
            break;
        
        case 4:
            if(t0_interrutp_counter < 29U) t0_interrutp_counter += 1;
            else {
                t0_out_enable = 2U;
                t0_interrutp_counter = 0;
                t0_modulation_state = 5;
            }
            break;

        case 5:
            if(t0_interrutp_counter < 271U) t0_interrutp_counter += 1;
            else {
                t0_out_enable = 1U;
                t0_interrutp_counter = 0;
                t0_modulation_state = 6;
            }
            break;

        case 6:
            if(t0_interrutp_counter < 29U) t0_interrutp_counter += 1;
            else {
                t0_out_enable = 2U;
                t0_interrutp_counter = 0;
                t0_modulation_state = 7;
            }
            break;

        case 7:
            if(t0_interrutp_counter < 4853U) t0_interrutp_counter += 1;
            else {
                t0_out_enable = 1U;
                t0_interrutp_counter = 0;
                t0_modulation_state = 0;
            }
            break;
    }
}
